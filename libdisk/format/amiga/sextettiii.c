/*
 * disk/evolution_cryser.c
 *
 * Custom format as used on Evolution Cryser & Mind Force by Kingsoft
 *
 * Written in 2023 by Keith Krellwitz
 *
 * RAW TRACK LAYOUT:
 *  u16 Sync :: Multiple syncs 0x2891, 0x2244, 0xa244, 0x9448, 0x4489
 *  u16 0 :: padding
 *  u32 dat[ti->len/4]
 *  u32 raw value - could not find any significance
 *
 * The tracks do not have checksums
 * 
 * TRKTYP_evolution_cryser data layout:
 *  u8 sector_data[6300]
 * 
 * TRKTYP_mind_force data layout:
 *  u8 sector_data[6300]
 * 
 */

#include <libdisk/util.h>
#include <private/disk.h>


static const uint16_t evolution_cryser_crcs[];
static const uint16_t evolution_cryser_syncs[];
static const uint16_t mind_force_crcs[];
static const uint16_t mind_force_syncs[];

static void *sextett_3_write_raw(
    struct disk *d, unsigned int tracknr, struct stream *s)
{
    struct track_info *ti = &d->di->track[tracknr];

    while (stream_next_bit(s) != -1) {
        uint32_t raw[2], dat[ti->len/4+1];
        char *block;
        unsigned int i;

        if (tracknr > 137)
            goto fail;
        if (ti->type == TRKTYP_evolution_cryser) {
            if ((uint16_t)s->word != evolution_cryser_syncs[tracknr])
                continue;
        }
        else {
            if ((uint16_t)s->word != mind_force_syncs[tracknr])
                continue;
        }
        ti->data_bitoff = s->index_offset_bc - 15;

        stream_start_crc(s);
        if (stream_next_bits(s, 32) == -1)
            goto fail;
        if (mfm_decode_word(s->word) != 0)
            continue;

        for (i = 0; i < ti->len/4; i++) {
            if (stream_next_bytes(s, raw, 8) == -1)
                goto fail;
            mfm_decode_bytes(bc_mfm_even_odd, 4, raw, &dat[i]);
        }

        if (ti->type == TRKTYP_evolution_cryser) {
            if(s->crc16_ccitt != evolution_cryser_crcs[tracknr])
                continue;
        } else {
            if(s->crc16_ccitt != mind_force_crcs[tracknr])
                continue;
        }

        // get last raw u32 and pass it via dat
        if (stream_next_bits(s, 32) == -1)
            goto fail;
        dat[ti->len/4] = s->word;

        stream_next_index(s);
        block = memalloc(ti->len+4);
        memcpy(block, dat, ti->len+4);
        set_all_sectors_valid(ti);
        ti->total_bits = s->track_len_bc;
        return block;
    }

fail:
    return NULL;
}

static void sextett_3_read_raw(
    struct disk *d, unsigned int tracknr, struct tbuf *tbuf)
{
    struct track_info *ti = &d->di->track[tracknr];
    uint32_t *dat = (uint32_t *)ti->dat, sum;
    unsigned int i;

    if (ti->type == TRKTYP_evolution_cryser)
        tbuf_bits(tbuf, SPEED_AVG, bc_raw, 16, evolution_cryser_syncs[tracknr]);
    else
        tbuf_bits(tbuf, SPEED_AVG, bc_raw, 16, mind_force_syncs[tracknr]);
    tbuf_bits(tbuf, SPEED_AVG, bc_raw, 32, 0xaaaaaaaa);

    for (i = sum = 0; i < ti->len/4; i++) {
        tbuf_bits(tbuf, SPEED_AVG, bc_mfm_even_odd, 32, be32toh(dat[i]));
        sum += be32toh(dat[i]);
    }
   tbuf_bits(tbuf, SPEED_AVG, bc_mfm_even_odd, 32, dat[ti->len]);
}

struct track_handler evolution_cryser_handler = {
    .bytes_per_sector = 6300,
    .nr_sectors = 1,
    .write_raw = sextett_3_write_raw,
    .read_raw = sextett_3_read_raw
};

struct track_handler mind_force_handler = {
    .bytes_per_sector = 6300,
    .nr_sectors = 1,
    .write_raw = sextett_3_write_raw,
    .read_raw = sextett_3_read_raw
};

static const uint16_t evolution_cryser_crcs[] = {
    0x0000, 0x0000, 0xe018, 0x1635, 0x6a6c, 0x6de3, 0x2689, 0xe355, 
    0xf33a, 0x96ad, 0x6fee, 0x67b7, 0xb334, 0x1977, 0xf5c4, 0x7eb8, 
    0x5c1a, 0x1ebf, 0xb13d, 0x334a, 0xdde2, 0x4f9f, 0x4e5a, 0x0e53, 
    0xba49, 0x1c79, 0xa730, 0x073a, 0x57ff, 0xee84, 0x7777, 0xb48c, 
    0xec23, 0xe707, 0xf93b, 0x1deb, 0xaa54, 0xbb80, 0xcf5e, 0xdc1f, 
    0x5e25, 0x7d69, 0x7288, 0xde95, 0x289b, 0x2e89, 0x3075, 0x0f62, 
    0xe2dd, 0xead6, 0xd1b9, 0x36ea, 0xbbc1, 0x0686, 0xb830, 0x8374, 
    0x25c3, 0x93fc, 0x5a2e, 0xa08a, 0xeb47, 0x2f15, 0x28d1, 0x6440, 
    0x5fe0, 0x6095, 0x2d9e, 0x763c, 0xe625, 0x5da1, 0xe566, 0x0438, 
    0xdfc8, 0xcd44, 0x7b4b, 0x5da1, 0x3caf, 0x1050, 0x1ed3, 0x050d, 
    0xbd00, 0x5da1, 0x465a, 0xbbc7, 0x005f, 0xbac0, 0xaa3c, 0xb2d4, 
    0x1df6, 0x997d, 0x587c, 0x6176, 0xc717, 0x25f1, 0x5d12, 0x2601, 
    0x2d3f, 0x997d, 0x1ce2, 0x21bb, 0xacdb, 0x1c6e, 0x2e10, 0x3863, 
    0x874c, 0xb204, 0xe67c, 0xdbb0, 0x13f5, 0xa52f, 0xeb34, 0x2f77, 
    0x2289, 0xdca4, 0xc09c, 0xddf9, 0xf859, 0xdbb0, 0x99f0, 0x091f, 
    0x2e10, 0x150b, 0xce10, 0xb5b8, 0x3117, 0x6c9d, 0x51a0, 0xa52f, 
    0x17b6, 0xe8cd, 0x4493, 0x2375, 0xc81b, 0x054e, 0xd50d, 0xd665, 
    0xb720, 0xd278, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
};

static const uint16_t evolution_cryser_syncs[] = {
    //0 - added to support probe all
    0x0000, 0x0000,
    //2
    0x2891, 0x2891, 
    //4
    0x2244, 0x2244, 0x2244, 0x2244, 0x2244, 0x2244, 0x2244, 0x2244,
    0x2244, 0x2244, 0x2244, 0x2244, 
    //16
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244,
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 
    //32
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244,
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 
    //48
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 
    //64
    0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 
    //70
    0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 
    //76
    0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 
    //82
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489,
    //90
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489,
    //98
    0x4489, 0x4489,
    //100
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489,
    0x4489, 0x4489,
    //110
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489,
    //118
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489,
    0x4489, 0x4489,
    //128
    0x2244, 0x2244, 0x2244, 0x2244,
    //132
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244,
    //138 on not used
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244,
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244,
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244
};

static const uint16_t mind_force_crcs[] = {
    0x0000, 0x31d3, 0x252c, 0x8e8d, 0x621d, 0x7817, 0x52f8, 0xfba1,
    0xdb3a, 0xa89b, 0xc846, 0x558e, 0xd683, 0x270f, 0x82f9, 0xa2a3,
    0x7d47, 0x8ba3, 0x16aa, 0x761f, 0x4dca, 0x6865, 0x898f, 0x9d48,
    0x27fd, 0xe507, 0xa69e, 0x80bb, 0x11a0, 0x4c0b, 0x3fd9, 0x7531,
    0x3f13, 0x73b8, 0x4dae, 0x32e0, 0x6cd1, 0x7c84, 0xf16a, 0x5cfa,
    0x4628, 0xaf86, 0x51a2, 0xe3d3, 0xa667, 0x8eaf, 0x90c0, 0xafc7,
    0x2650, 0x08ef, 0xad71, 0xe401, 0x02f8, 0x85c9, 0x3cae, 0xa889,
    0x8a94, 0x5e39, 0x544b, 0xdc34, 0xb6e5, 0x5975, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff

};

static const uint16_t mind_force_syncs[] = {
    0x0000, 0x2244, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489,
    0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 0x4489, 
    0x4489, 0x2891, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 
    0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244, 0xa244,
    0xa244, 0xa244, 0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 
    0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 0x9448, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
};

/*
 * Local variables:
 * mode: C
 * c-file-style: "Linux"
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
